trigger:
- main

pool:
  vmImage: 'windows-latest'

variables:
  # Flip to 'true' only when you actually enable the Sign stage below
  EnableCodeSigning: 'false'
  # Keep a simple default; weâ€™ll pick the right artifact via step conditions
  ArtifactNameVar: 'drop'

stages:
# -----------------------
# Stage 1: Build
# -----------------------
- stage: Build
  displayName: "Build & Package"
  jobs:
  - job: Build
    steps:
    # Optional lint (handles multiple folders safely)
    - task: PowerShell@2
      displayName: "Lint scripts (PSScriptAnalyzer)"
      inputs:
        targetType: inline
        script: |
          Install-Module PSScriptAnalyzer -Force -Scope CurrentUser
          Get-ChildItem -Path "$(Build.SourcesDirectory)" -Recurse -Include *.ps1 |
            ForEach-Object {
              Invoke-ScriptAnalyzer -Path $_.FullName -EnableExit
            }

    # Package repo into zip
    - task: PowerShell@2
      displayName: "Package repository to ZIP"
      inputs:
        targetType: inline
        script: |
          $zipPath = "$(Build.ArtifactStagingDirectory)\analytics-workstation.zip"
          Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
          [System.IO.Compression.ZipFile]::CreateFromDirectory("$(Build.SourcesDirectory)", $zipPath)

    - task: PublishBuildArtifacts@1
      displayName: "Publish artifact (drop)"
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

# -----------------------
# Stage 2: Code Signing (optional placeholder)
# -----------------------
- stage: Sign
  displayName: "Code Signing"
  dependsOn: Build
  condition: eq(variables['EnableCodeSigning'], 'true')
  jobs:
  - job: Sign
    steps:
    # Download the unsigned artifact from Build
    - download: current
      artifact: drop

    # TODO: replace with real signing if/when you add cert + password
    - task: PowerShell@2
      displayName: "Signing placeholder"
      inputs:
        targetType: inline
        script: |
          Write-Host "Add DownloadSecureFile + Import-PfxCertificate + Set-AuthenticodeSignature here."

    # Publish a 'signed' artifact (even if placeholder for now)
    - task: PublishBuildArtifacts@1
      displayName: "Publish signed artifact"
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'signed'

# -----------------------
# Stage 3: Deploy to Pilot
# -----------------------
- stage: Pilot
  displayName: "Deploy to Pilot"
  dependsOn: [Build, Sign]
  jobs:
  - deployment: PilotDeploy
    environment: Pilot-Release
    strategy:
      runOnce:
        deploy:
          steps:
          # Default: use 'drop' artifact when signing is OFF
          - download: current
            artifact: drop
            condition: ne(variables['EnableCodeSigning'], 'true')

          # If signing is ON, use 'signed'
          - download: current
            artifact: signed
            condition: eq(variables['EnableCodeSigning'], 'true')

          - task: PowerShell@2
            displayName: "Pilot no-op"
            inputs:
              targetType: inline
              script: |
                Write-Host "Pilot: fetched artifact (signed? $(EnableCodeSigning))."

# -----------------------
# Stage 4: Deploy to Prod
# -----------------------
- stage: Prod
  displayName: "Deploy to Production"
  dependsOn: Pilot
  jobs:
  - deployment: ProdDeploy
    environment: Prod-Release
    strategy:
      runOnce:
        deploy:
          steps:
          # Default: use 'drop'
          - download: current
            artifact: drop
            condition: ne(variables['EnableCodeSigning'], 'true')

          # If signing is ON, use 'signed'
          - download: current
            artifact: signed
            condition: eq(variables['EnableCodeSigning'], 'true')

          - task: PowerShell@2
            displayName: "Prod no-op"
            inputs:
              targetType: inline
              script: |
                Write-Host "Prod: fetched artifact (signed? $(EnableCodeSigning))."
